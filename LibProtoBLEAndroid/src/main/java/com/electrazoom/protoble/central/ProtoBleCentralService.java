/*
 * ProtoBLE - Protobuf RPC over Bluetooth Low Energy
 * Copyright (c) 2018. Geoffrey Matrangola, electrazoom.com
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>
 *
 *     This program is also available under a commercial license. If you wish
 *     to redistribute this library and derivative work for commercial purposes
 *     please see ProtoBLE.com to obtain a proprietary license that will fit
 *     your needs.
 */

package com.electrazoom.protoble.central;

import android.app.Service;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothProfile;
import android.content.Intent;
import android.os.Build;
import android.util.Log;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import static android.bluetooth.BluetoothGatt.GATT_SUCCESS;
import static com.electrazoom.protoble.central.OutputCharacteristicHandler.CCCD_UUID;

/**
 * This is the base class for the Android services generated by the CodeGen Android code generator.
 * Node tht this is not the BLE Service, but an Android Service. It has the utility methods
 * for handeling interface with the Bluetooth GATT that will connect to a service, register
 * for notifications from the characteristics etc.
 */
public abstract class ProtoBleCentralService extends Service {
    private static final String TAG = "ProtoBleService";

    // GUID for my app, get your own! try https://www.guidgenerator.com
    private UUID serviceUuid;

    BluetoothGatt gattConnection = null;
    private boolean isRunning = true;

    private Map<UUID, InputCharacteristicHandler> inputCharacteristics = new HashMap<>();
    private Map<UUID, OutputCharacteristicHandler> outputCharacteristics = new HashMap<>();
    private boolean isRegersting;
    private int registeredCccd = 0;

    public interface ServiceListener {
        void onServiceConnected();
        void onConnectionStateChange(int state);
        void onError(String error);
        void onProgress(UUID uuid, int current, int total);
    }
    public interface ResponseListener {
        void onResponse(byte[] message);
        void onError(String error);
    }
    private class CccdRegistry {
        BluetoothGatt gatt;
        OutputCharacteristicHandler handler;
    }

    private Deque<CccdRegistry> registryQueue = new ArrayDeque<>();

    private ServiceListener listener;

    @Override
    public boolean onUnbind(Intent intent) {
        Log.d(TAG, "onUnbind");
        listener = null;
        return super.onUnbind(intent);
    }

    private BluetoothGattCallback gattCallback = new BluetoothGattCallback() {
        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
            Log.d(TAG, "onConnectionStateChange status= " + status + " state= " + newState + " gatt= " + gatt);
            if (gatt.equals(gattConnection)) {
                if (listener != null) listener.onConnectionStateChange(newState);
                if (newState == BluetoothProfile.STATE_CONNECTED) {
                    gatt.discoverServices();
                }
                else if (newState == BluetoothProfile.STATE_DISCONNECTED){
                    notifyError("Connection lost");
                    gatt.disconnect();
                    gatt.close();
                }
            }
            else {
                Log.d(TAG, "disconnecting gatt " + gatt);
                gatt.disconnect();
                gatt.close();
            }
        }

        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
            Log.d(TAG, "onServicesDiscovered gatt: " + gatt + " status: " + status);
            if (GATT_SUCCESS == status && gattConnection.equals(gatt)) {
                BluetoothGattService protoService = gatt.getService(serviceUuid);
                for (Map.Entry<UUID, OutputCharacteristicHandler> entry : outputCharacteristics.entrySet()) {
                    BluetoothGattCharacteristic characteristic = protoService.getCharacteristic(entry.getKey());
                    entry.getValue().setCharacteristic(characteristic);
                    CccdRegistry cccdRegistry = new CccdRegistry();
                    cccdRegistry.gatt = gatt;
                    cccdRegistry.handler = entry.getValue();
                    registryQueue.add(cccdRegistry);
                }

                for (Map.Entry<UUID, InputCharacteristicHandler> entry : inputCharacteristics.entrySet()) {
                    entry.getValue().setCharacteristic(protoService.getCharacteristic(entry.getKey()));
                }
                registerNextCccd();
            }
            else notifyError("Service Discovery Failed. status: " + status);
        }

        @Override
        public void onCharacteristicRead(BluetoothGatt gatt,
                                         BluetoothGattCharacteristic characteristic, int status) {
            Log.d(TAG, "onCharacteristicRead " + status);
            if (GATT_SUCCESS == status && null != characteristic && gatt.equals(gattConnection)) {
                OutputCharacteristicHandler handler = outputCharacteristics.get(characteristic.getUuid());
                if (handler != null) handler.handleResponse();
                else notifyError("No output characteristic " + characteristic.getUuid());
            }
        }

        @Override
        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
            if (status == GATT_SUCCESS && gatt.equals(gattConnection)) {
                InputCharacteristicHandler handler = inputCharacteristics.get(characteristic.getUuid());
                if (handler == null) notifyError("No input characteristic " + characteristic.getUuid());
            }
            else notifyError("Write failure status: %d", status);
        }

        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
            if (gatt.equals(gattConnection)) {
                Log.d(TAG, "onCharacteristic changed: " + characteristic.getUuid());
                OutputCharacteristicHandler handler = outputCharacteristics.get(characteristic.getUuid());
                if (handler != null) handler.handleResponse();
                else notifyError("No output characteristic " + characteristic.getUuid());
            }
            else {
                Log.w(TAG, "onCharacteristicChanged old gatt = " + gatt);
            }
        }

        @Override
        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
            Log.d(TAG, "onDescriptorWrite " + status + "gatt: " + gatt);
            if (descriptor.getUuid().equals(CCCD_UUID) && gatt.equals(gattConnection)) {
                if (GATT_SUCCESS == status) {
                    Log.i(TAG, "Notification Registration successful " + descriptor.getUuid());
                    isRegersting = false;
                    registeredCccd++;
                    if (null != listener && registeredCccd == outputCharacteristics.size()) {
                        listener.onServiceConnected();
                    }
                    registerNextCccd();
                }
                else notifyError("Notification Registration failed. status: %d", status);
            }
        }
    };

    private void registerNextCccd() {
        if (!isRegersting && !registryQueue.isEmpty()) {
            isRegersting = true;
            CccdRegistry cccd = registryQueue.removeFirst();
            try {
                cccd.handler.registerCccd(cccd.gatt);
            } catch (CentralServiceException e) {
                Log.e(TAG, "Unable to register cccd: " + cccd.handler.getUuid(), e);
            }
        }
    }

    private void notifyError(String message, Object... args) {
        String format = String.format(message, args);
        Log.e(TAG, format);
        if (null != listener) listener.onError(format);
    }

    void notifyProgress(UUID uuid, int current, int total) {
        if (null != listener) listener.onProgress(uuid, current, total);
    }


    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "onCreate");
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");

        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        Log.d(TAG, "onDestroy");
        isRunning = false;
        disconnect();
        listener = null;
        super.onDestroy();
    }

    public void setServiceUuid(UUID serviceUuid) {
        this.serviceUuid = serviceUuid;
    }

    public void addInputCharacteristic(UUID uuid, ResponseListener listener) {
        if (!inputCharacteristics.containsKey(uuid)) {
            InputCharacteristicHandler inputCharacteristicHandler = new InputCharacteristicHandler(
                    this, uuid, listener);
            inputCharacteristics.put(uuid, inputCharacteristicHandler);
        }
    }

    public void addOutputCharacteristic(UUID uuid, ResponseListener listener) {
        if (!outputCharacteristics.containsKey(uuid)) {
            OutputCharacteristicHandler outputCharacteristicHandler = new
                    OutputCharacteristicHandler(this, uuid, listener);
            outputCharacteristics.put(uuid, outputCharacteristicHandler);
        }
    }

    /**
     * Connect to the remote device found during the scan for the Service GUID
     * @param device BlueoothDevice selected
     */
    public void connect(BluetoothDevice device) throws CentralServiceException {
        if (serviceUuid == null) throw new CentralServiceException("Service UUID not set");
        if (inputCharacteristics.isEmpty()) throw new CentralServiceException("No Input Characteristic UUIDs registered");
        if (outputCharacteristics.isEmpty()) throw new CentralServiceException("No Output Characteristic UUIDs registered");

        for (InputCharacteristicHandler inputCharacteristicHandler : inputCharacteristics.values()) {
            inputCharacteristicHandler.onConnect();
        }

        for (OutputCharacteristicHandler outputCharacteristicHandler : outputCharacteristics.values()) {
            outputCharacteristicHandler.onConnect();
        }

        Log.i(TAG, "Connecting to Service on " + device);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            gattConnection = device.connectGatt(this, false, gattCallback, BluetoothDevice.TRANSPORT_LE);
        }
        else {
            Log.w(TAG, "Using OLD Connect");
            gattConnection = device.connectGatt(this, false, gattCallback);
        }
        boolean status = gattConnection.connect();
        if (!status) notifyError("GATT Connection request failed");
        else Log.i(TAG, "GATT Connection requested " + gattConnection);
    }

    public void disconnect() {
        Log.i(TAG, "disconnect gatt = " + gattConnection);
        if (gattConnection != null) {
            gattConnection.disconnect();
            gattConnection.close();
            gattConnection = null;
        }
    }

    public void writeMessage(UUID inputCharacteristicUuid, byte[] message) throws CentralServiceException {
        InputCharacteristicHandler characteristic = inputCharacteristics.get(inputCharacteristicUuid);
        if (characteristic == null) throw new CentralServiceException("No input characteristic for "
                + inputCharacteristicUuid );
        characteristic.writeMessage(message);
    }

    public BluetoothGatt getGattConnection() {
        return gattConnection;
    }

    public boolean isRunning() {
        return isRunning;
    }

    protected void setListener(ServiceListener listener) {
        this.listener = listener;
    }

}
